# Multi-service MCP Tools Container
# Provides useful tools for the Replicante agent: calculations, time, weather, HTTP requests

FROM python:3.11-alpine

# Install system dependencies
RUN apk add --no-cache \
    curl \
    ca-certificates \
    bash \
    && rm -rf /var/cache/apk/*

# Create app directory
WORKDIR /app

# Copy MCP server scripts
COPY test/mock_mcp_server.py /app/
COPY test/http_mcp_server.py /app/
COPY docker/mcp-tools-client.py /usr/local/bin/mcp-tools-client.py

# Make client script executable
RUN chmod +x /usr/local/bin/mcp-tools-client.py

# Create a supervisor script to run multiple MCP servers
RUN cat > /app/run_servers.py << 'EOF'
#!/usr/bin/env python3
"""
Multi-MCP server runner
Starts multiple MCP servers based on environment configuration
"""
import os
import sys
import subprocess
import signal
import time
from threading import Thread

class MCPServerManager:
    def __init__(self):
        self.servers = []
        self.running = True
    
    def start_server(self, name, script, port_offset=0):
        """Start an MCP server"""
        print(f"Starting MCP server: {name}")
        
        # For stdio-based MCP servers, we'll run them as services
        # listening on stdin/stdout
        if name == "mock":
            process = subprocess.Popen([
                "python", "-u", script
            ], stdin=subprocess.PIPE, stdout=subprocess.PIPE, 
               stderr=subprocess.PIPE, bufsize=0)
        elif name == "http":
            process = subprocess.Popen([
                "python", "-u", script  
            ], stdin=subprocess.PIPE, stdout=subprocess.PIPE,
               stderr=subprocess.PIPE, bufsize=0)
        else:
            print(f"Unknown server type: {name}")
            return None
            
        self.servers.append((name, process))
        print(f"Started {name} server with PID {process.pid}")
        return process
    
    def stop_all(self):
        """Stop all servers"""
        print("Stopping all MCP servers...")
        self.running = False
        
        for name, process in self.servers:
            print(f"Stopping {name}...")
            try:
                process.terminate()
                process.wait(timeout=5)
            except subprocess.TimeoutExpired:
                process.kill()
                process.wait()
            print(f"Stopped {name}")
    
    def run(self):
        """Main run loop"""
        # Start the primary HTTP MCP server
        # This will be the main server that Replicante connects to
        self.start_server("http", "/app/http_mcp_server.py")
        
        # Keep running
        try:
            while self.running:
                # Check if any servers died
                for name, process in self.servers:
                    if process.poll() is not None:
                        print(f"Server {name} died, restarting...")
                        self.servers.remove((name, process))
                        if name == "http":
                            self.start_server("http", "/app/http_mcp_server.py")
                
                time.sleep(5)
        except KeyboardInterrupt:
            print("Received interrupt signal")
        finally:
            self.stop_all()

def signal_handler(signum, frame):
    print("Received shutdown signal")
    manager.stop_all()
    sys.exit(0)

if __name__ == "__main__":
    signal.signal(signal.SIGTERM, signal_handler)
    signal.signal(signal.SIGINT, signal_handler)
    
    manager = MCPServerManager()
    manager.run()
EOF

# Make the supervisor script executable
RUN chmod +x /app/run_servers.py

# For direct MCP server access, we'll run the HTTP server by default
# The Replicante agent will connect to it via stdio
EXPOSE 5000

# Health check
HEALTHCHECK --interval=30s --timeout=5s --start-period=10s --retries=3 \
    CMD python -c "import sys; sys.exit(0)"

# Run the HTTP MCP server directly
# This allows Replicante to spawn it as a subprocess
CMD ["python", "-u", "/app/http_mcp_server.py"]