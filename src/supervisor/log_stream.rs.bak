use anyhow::Result;
use futures::StreamExt;
use std::sync::Arc;
use warp::sse::Event;
use warp::{Filter, Rejection, Reply};

use super::container_manager::ContainerManager;
use super::Supervisor;

/// Create a Server-Sent Events stream for container logs
pub async fn create_log_stream(
    agent_id: String,
    tail: Option<usize>,
    supervisor: Arc<Supervisor>,
) -> Result<impl warp::Reply, Rejection> {
    // Get container ID for the agent
    let agents_ref = supervisor.get_agents_ref();
    let agents = agents_ref.read().await;
    
    if let Some(agent) = agents.get(&agent_id) {
        if let Some(container_id) = &agent.container_id {
            let container_id = container_id.clone();
            drop(agents); // Release the lock
            
            let container_manager = supervisor.get_container_manager_ref();
            let tail_str = tail.map(|n| n.to_string());
            
            // Create log stream from container
            match container_manager.stream_container_logs(&container_id, true, tail_str).await {
                Ok(log_stream) => {
                    // Convert container logs to SSE events
                    let event_stream = log_stream
                        .map(move |result| {
                            match result {
                                Ok(log_line) => {
                                    // Create SSE event with log data
                                    Ok::<_, warp::Error>(
                                        Event::default()
                                            .event("log")
                                            .data(log_line)
                                    )
                                }
                                Err(e) => {
                                    // Send error as event
                                    Ok(Event::default()
                                        .event("error")
                                        .data(format!("Error: {}", e))
                                    )
                                }
                            }
                        });
                    
                    Ok(warp::sse::reply(event_stream))
                }
                Err(e) => {
                    // Return error as SSE stream with single error event
                    let error_stream = futures::stream::once(async move {
                        Ok::<_, warp::Error>(
                            Event::default()
                                .event("error")
                                .data(format!("Failed to start log stream: {}", e))
                        )
                    });
                    Ok(warp::sse::reply(error_stream))
                }
            }
        } else {
            // No container for agent
            let error_stream = futures::stream::once(async move {
                Ok::<_, warp::Error>(
                    Event::default()
                        .event("error")
                        .data(format!("No container found for agent {}", agent_id))
                )
            });
            Ok(warp::sse::reply(error_stream))
        }
    } else {
        // Agent not found
        let error_stream = futures::stream::once(async move {
            Ok::<_, warp::Error>(
                Event::default()
                    .event("error")
                    .data(format!("Agent {} not found", agent_id))
            )
        });
        Ok(warp::sse::reply(error_stream))
    }
}

/// Create the log streaming route filter
pub fn log_stream_route(
    supervisor: Arc<Supervisor>,
) -> impl Filter<Extract = impl Reply, Error = Rejection> + Clone {
    warp::path!("api" / "agents" / String / "logs" / "stream")
        .and(warp::get())
        .and(warp::query::<LogStreamQuery>())
        .and(with_supervisor(supervisor))
        .and_then(handle_log_stream)
}

#[derive(Debug, serde::Deserialize)]
struct LogStreamQuery {
    tail: Option<usize>,
}

async fn handle_log_stream(
    agent_id: String,
    query: LogStreamQuery,
    supervisor: Arc<Supervisor>,
) -> Result<impl Reply, Rejection> {
    create_log_stream(agent_id, query.tail, supervisor).await
}

fn with_supervisor(
    supervisor: Arc<Supervisor>,
) -> impl Filter<Extract = (Arc<Supervisor>,), Error = std::convert::Infallible> + Clone {
    warp::any().map(move || supervisor.clone())
}